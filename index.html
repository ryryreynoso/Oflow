<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>BTC Professional Orderflow</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        background: #000000;
        color: #fff;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
    }

    /* Top Header Bar */
    .top-bar {
        height: 60px;
        background: #0a0a0a;
        border-bottom: 1px solid #1a1a1a;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 20px;
    }

    .menu-icon {
        width: 40px;
        height: 40px;
        border: 2px solid #2a2a2a;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #888;
    }

    .menu-icon:hover {
        background: #1a1a1a;
    }

    .indicators-btn {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 10px 16px;
        background: transparent;
        border: none;
        color: #888;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
    }

    .indicators-btn:hover {
        color: #fff;
    }

    .top-bar-spacer {
        flex: 1;
    }

    .grid-btn, .settings-btn {
        width: 40px;
        height: 40px;
        background: #ff6b35;
        border: none;
        border-radius: 6px;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .settings-btn {
        background: transparent;
        border: 2px solid #2a2a2a;
        color: #888;
    }

    /* Symbol Header */
    .symbol-header {
        height: 70px;
        background: #0a0a0a;
        border-bottom: 1px solid #1a1a1a;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 16px;
    }

    .symbol-badge {
        background: #1a1a1a;
        padding: 8px 14px;
        border-radius: 8px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .exchange-logo {
        width: 24px;
        height: 24px;
        background: #fff;
        border-radius: 50%;
    }

    .symbol-name {
        font-size: 16px;
        font-weight: 700;
        color: #fff;
    }

    .symbol-type {
        font-size: 11px;
        color: #888;
    }

    .timeframe-group {
        display: flex;
        gap: 4px;
        background: #1a1a1a;
        padding: 4px;
        border-radius: 8px;
    }

    .tf-btn {
        padding: 8px 14px;
        background: transparent;
        border: none;
        color: #888;
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        border-radius: 6px;
        transition: all 0.2s;
    }

    .tf-btn.active {
        background: #2563eb;
        color: #fff;
    }

    .tf-btn:hover:not(.active) {
        background: #2a2a2a;
    }

    .expand-icon {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #888;
        cursor: pointer;
    }

    .current-price {
        font-size: 18px;
        font-weight: 700;
        color: #fff;
        margin-left: auto;
    }

    /* Main Container */
    .main-container {
        height: calc(100vh - 130px);
        display: flex;
    }

    /* Left Toolbar */
    .left-toolbar {
        width: 60px;
        background: #0a0a0a;
        border-right: 1px solid #1a1a1a;
        display: flex;
        flex-direction: column;
        padding: 12px 8px;
        gap: 8px;
    }

    .tool-icon {
        width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: transparent;
        border: none;
        color: #888;
        font-size: 20px;
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s;
    }

    .tool-icon:hover {
        background: #1a1a1a;
    }

    .tool-icon.active {
        background: #2563eb;
        color: #fff;
    }

    /* Chart Area */
    .chart-area {
        flex: 1;
        display: flex;
        flex-direction: column;
        background: #000000;
        position: relative;
    }

    .chart-canvas-wrapper {
        flex: 1;
        position: relative;
    }

    canvas {
        display: block;
        cursor: crosshair;
    }

    /* CVD Bar */
    .cvd-bar {
        height: 40px;
        background: #0a0a0a;
        border-top: 1px solid #1a1a1a;
        border-bottom: 1px solid #1a1a1a;
        display: flex;
        align-items: center;
        padding: 0 20px;
        gap: 40px;
    }

    .cvd-label {
        font-size: 12px;
        color: #888;
        font-weight: 600;
    }

    .cvd-values {
        display: flex;
        gap: 30px;
    }

    .cvd-value {
        font-size: 14px;
        font-weight: 700;
    }

    .cvd-value.positive {
        color: #10b981;
    }

    .cvd-value.negative {
        color: #ef4444;
    }

    /* Footprint Stats Bar */
    .footprint-bar {
        height: 200px;
        background: linear-gradient(to top, #0a0a0a 0%, rgba(10, 10, 10, 0.95) 70%, transparent 100%);
        border-top: 1px solid #1a1a1a;
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
        position: relative;
    }

    .footprint-bar::-webkit-scrollbar {
        height: 6px;
    }

    .footprint-bar::-webkit-scrollbar-track {
        background: #0a0a0a;
    }

    .footprint-bar::-webkit-scrollbar-thumb {
        background: #2a2a2a;
        border-radius: 3px;
    }

    .fp-column {
        min-width: 140px;
        max-width: 140px;
        flex-shrink: 0;
        border-right: 1px solid #1a1a1a;
        display: flex;
        flex-direction: column;
    }

    .fp-title-row {
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-bottom: 1px solid #1a1a1a;
        background: rgba(26, 26, 26, 0.5);
    }

    .fp-title {
        font-size: 11px;
        color: #888;
        font-weight: 600;
    }

    .fp-stats-grid {
        flex: 1;
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1px;
        background: #1a1a1a;
        padding: 1px;
    }

    .fp-stat-cell {
        background: #0a0a0a;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px;
    }

    .fp-stat-value {
        font-size: 16px;
        font-weight: 700;
    }

    .fp-stat-value.positive {
        color: #10b981;
    }

    .fp-stat-value.negative {
        color: #ef4444;
    }

    .fp-stat-label {
        font-size: 9px;
        color: #888;
        margin-top: 2px;
    }

    /* Right Price Scale */
    .price-scale {
        position: absolute;
        right: 0;
        top: 0;
        bottom: 0;
        width: 80px;
        pointer-events: none;
    }

    .current-price-label {
        position: absolute;
        right: 0;
        background: #fbbf24;
        color: #000;
        padding: 4px 8px;
        font-size: 12px;
        font-weight: 700;
        border-radius: 4px 0 0 4px;
    }

    /* Connection Status */
    .status-indicator {
        position: fixed;
        top: 70px;
        right: 20px;
        padding: 6px 12px;
        background: rgba(16, 185, 129, 0.15);
        border: 1px solid rgba(16, 185, 129, 0.4);
        border-radius: 6px;
        display: flex;
        align-items: center;
        gap: 8px;
        z-index: 1000;
    }

    .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #10b981;
        animation: pulse 2s infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; box-shadow: 0 0 8px rgba(16, 185, 129, 0.8); }
        50% { opacity: 0.6; box-shadow: 0 0 4px rgba(16, 185, 129, 0.4); }
    }

    .status-text {
        font-size: 11px;
        color: #10b981;
        font-weight: 600;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
        .top-bar {
            padding: 0 12px;
            gap: 12px;
        }
        
        .indicators-btn {
            display: none;
        }
        
        .symbol-header {
            padding: 0 12px;
            gap: 8px;
        }
        
        .tf-btn {
            padding: 6px 10px;
            font-size: 12px;
        }
        
        .fp-column {
            min-width: 100px;
            max-width: 100px;
        }
    }
</style>
```

</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
        <div class="menu-icon">â˜°</div>
        <button class="indicators-btn">
            ðŸ“Š Indicators
        </button>
        <div class="top-bar-spacer"></div>
        <div class="grid-btn">âŠž</div>
        <div class="settings-btn">âš™</div>
        <div class="menu-icon">â‹®</div>
    </div>

```
<!-- Symbol Header -->
<div class="symbol-header">
    <div class="symbol-badge">
        <div class="exchange-logo"></div>
        <div>
            <div class="symbol-type">BYBIT.F</div>
            <div class="symbol-name">BTCUSDT</div>
        </div>
    </div>
    
    <div class="timeframe-group">
        <button class="tf-btn" data-tf="60000">1m</button>
        <button class="tf-btn" data-tf="300000">5m</button>
        <button class="tf-btn active" data-tf="900000">15m</button>
        <button class="tf-btn" data-tf="3600000">1h</button>
        <button class="tf-btn" data-tf="14400000">4h</button>
    </div>
    
    <div class="expand-icon">â–¼</div>
    
    <div class="current-price" id="currentPrice">88270.30</div>
</div>

<!-- Connection Status -->
<div class="status-indicator">
    <div class="status-dot"></div>
    <span class="status-text">Live</span>
</div>

<!-- Main Container -->
<div class="main-container">
    <!-- Left Toolbar -->
    <div class="left-toolbar">
        <button class="tool-icon active" data-tool="cursor" title="Cursor">âŒ–</button>
        <button class="tool-icon" data-tool="line" title="Horizontal Line">â€•</button>
        <button class="tool-icon" data-tool="fib" title="Fibonacci">Ï†</button>
        <button class="tool-icon" data-tool="trend" title="Trend Line">ðŸ“ˆ</button>
    </div>

    <!-- Chart Area -->
    <div class="chart-area">
        <div class="chart-canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>

        <!-- CVD Bar -->
        <div class="cvd-bar">
            <span class="cvd-label">CVD</span>
            <div class="cvd-values" id="cvdValues">
                <!-- Dynamically populated -->
            </div>
        </div>

        <!-- Footprint Stats Bar -->
        <div class="footprint-bar" id="footprintBar">
            <!-- Dynamically populated -->
        </div>
    </div>
</div>

<script>
    // Global error handler
    window.onerror = function(message, source, lineno, colno, error) {
        console.error('âŒ ERROR:', message, 'at', lineno + ':' + colno);
        return false;
    };

    // Configuration
    const CONFIG = {
        candleWidth: 100,
        candleGap: 20,
        tickSize: 1.0,
        colors: {
            bg: '#000000',
            grid: '#1a1a1a',
            bullCandle: '#b8860b',
            bearCandle: '#cd853f',
            bullBorder: '#daa520',
            bearBorder: '#d2691e',
            currentCandle: '#fbbf24',
            bidVol: '#b8860b',
            askVol: '#cd853f',
            text: '#888'
        }
    };

    // State
    let candles = [];
    let currentCandle = null;
    let candleInterval = 15 * 60 * 1000; // 15 minutes
    let candleStartTime = alignToTimeframe(Date.now(), candleInterval);
    let zoomLevel = 1;
    let scrollOffset = 0;
    let socket = null;
    let isConnected = false;

    // Canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resizeCanvas() {
        const container = canvas.parentElement;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = container.clientWidth * dpr;
        canvas.height = container.clientHeight * dpr;
        canvas.style.width = container.clientWidth + 'px';
        canvas.style.height = container.clientHeight + 'px';
        ctx.scale(dpr, dpr);
        draw();
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Time alignment
    function alignToTimeframe(timestamp, interval) {
        const date = new Date(timestamp);
        if (interval >= 3600000) {
            const hours = date.getHours();
            const intervalHours = interval / 3600000;
            const alignedHours = Math.floor(hours / intervalHours) * intervalHours;
            date.setHours(alignedHours, 0, 0, 0);
        } else {
            const minutes = date.getMinutes();
            const intervalMinutes = interval / 60000;
            const alignedMinutes = Math.floor(minutes / intervalMinutes) * intervalMinutes;
            date.setMinutes(alignedMinutes, 0, 0);
        }
        return date.getTime();
    }

    // Bybit Connection
    function connectToBybit() {
        try {
            console.log('ðŸ”Œ Connecting to Bybit...');
            socket = new WebSocket('wss://stream.bybit.com/v5/public/linear');
            
            socket.onopen = () => {
                console.log('âœ… Connected to Bybit');
                isConnected = true;
                
                socket.send(JSON.stringify({
                    op: 'subscribe',
                    args: ['publicTrade.BTCUSDT', 'orderbook.50.BTCUSDT']
                }));
            };
            
            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.success) {
                        console.log('âœ… Subscription confirmed');
                        return;
                    }
                    
                    if (data.topic && data.topic.includes('publicTrade')) {
                        processTradeData(data);
                    }
                } catch (e) {
                    console.error('Parse error:', e);
                }
            };
            
            socket.onerror = (e) => {
                console.error('âŒ WebSocket error:', e);
                isConnected = false;
            };
            
            socket.onclose = (e) => {
                console.log('âš ï¸ Connection closed, reconnecting...');
                isConnected = false;
                setTimeout(connectToBybit, 5000);
            };
        } catch (error) {
            console.error('âŒ Connection failed:', error);
        }
    }

    function processTradeData(message) {
        if (!message.data || message.data.length === 0) return;
        
        message.data.forEach(trade => {
            const price = parseFloat(trade.p);
            const qty = parseFloat(trade.v);
            const isSell = trade.S === 'Sell';
            
            if (!currentCandle) {
                currentCandle = createNewCandle(price);
            }
            
            currentCandle.h = Math.max(currentCandle.h, price);
            currentCandle.l = Math.min(currentCandle.l, price);
            currentCandle.c = price;
            currentCandle.v += qty;
            
            const priceKey = price.toFixed(2);
            if (!currentCandle.fp[priceKey]) {
                currentCandle.fp[priceKey] = { b: 0, a: 0 };
            }
            
            if (isSell) {
                currentCandle.fp[priceKey].b += qty;
            } else {
                currentCandle.fp[priceKey].a += qty;
            }
            
            updatePriceDisplay(price);
            draw();
            updateFootprintBar();
            updateCVDBar();
        });
    }

    function createNewCandle(price) {
        const alignedTime = alignToTimeframe(Date.now(), candleInterval);
        return {
            t: alignedTime,
            o: price,
            h: price,
            l: price,
            c: price,
            v: 0,
            fp: {}
        };
    }

    function checkCandleInterval() {
        const now = Date.now();
        const currentAlignedTime = alignToTimeframe(now, candleInterval);
        
        if (currentAlignedTime > candleStartTime && currentCandle) {
            candles.push(currentCandle);
            if (candles.length > 200) {
                candles.shift();
            }
            currentCandle = null;
            candleStartTime = currentAlignedTime;
        }
    }
    setInterval(checkCandleInterval, 1000);

    function updatePriceDisplay(price) {
        document.getElementById('currentPrice').textContent = price.toFixed(2);
    }

    // Drawing
    function draw() {
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);

        ctx.fillStyle = CONFIG.colors.bg;
        ctx.fillRect(0, 0, w, h);

        const allCandles = [...candles];
        if (currentCandle) allCandles.push(currentCandle);

        if (allCandles.length === 0) return;

        // Price range
        let minPrice = Infinity;
        let maxPrice = -Infinity;

        allCandles.forEach(c => {
            minPrice = Math.min(minPrice, c.l);
            maxPrice = Math.max(maxPrice, c.h);
        });

        const padding = (maxPrice - minPrice) * 0.15;
        minPrice -= padding;
        maxPrice += padding;

        // Grid
        drawGrid(w, h, minPrice, maxPrice);

        // Candles
        const candleW = CONFIG.candleWidth * zoomLevel;
        const gap = CONFIG.candleGap * zoomLevel;
        const totalWidth = allCandles.length * (candleW + gap);
        const startX = w - totalWidth - 100 + scrollOffset;

        allCandles.forEach((candle, i) => {
            const x = startX + i * (candleW + gap);
            if (x + candleW < 0 || x > w - 80) return;
            drawCandle(candle, x, candleW, h, minPrice, maxPrice, i === allCandles.length - 1);
        });

        // Price scale
        drawPriceScale(w, h, minPrice, maxPrice);
    }

    function drawGrid(w, h, minPrice, maxPrice) {
        ctx.strokeStyle = CONFIG.colors.grid;
        ctx.lineWidth = 1;

        const step = 50;
        const startPrice = Math.floor(minPrice / step) * step;

        for (let p = startPrice; p <= maxPrice; p += step) {
            const y = h - ((p - minPrice) / (maxPrice - minPrice)) * h;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w - 80, y);
            ctx.stroke();
        }
    }

    function drawCandle(c, x, w, h, minPrice, maxPrice, isCurrent) {
        const priceToY = (price) => {
            return h - ((price - minPrice) / (maxPrice - minPrice)) * h;
        };

        const oy = priceToY(c.o);
        const cy = priceToY(c.c);
        const hy = priceToY(c.h);
        const ly = priceToY(c.l);

        const isGreen = c.c >= c.o;
        const borderColor = isCurrent ? CONFIG.colors.currentCandle : (isGreen ? CONFIG.colors.bullBorder : CONFIG.colors.bearBorder);
        const bodyColor = isGreen ? CONFIG.colors.bullCandle : CONFIG.colors.bearCandle;

        // Wick
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + w/2, hy);
        ctx.lineTo(x + w/2, ly);
        ctx.stroke();

        // Body
        const top = Math.min(oy, cy);
        const bodyH = Math.abs(cy - oy) || 2;

        ctx.fillStyle = bodyColor;
        ctx.fillRect(x + 2, top, w - 4, bodyH);

        ctx.strokeStyle = borderColor;
        ctx.lineWidth = isCurrent ? 3 : 2;
        ctx.strokeRect(x + 2, top, w - 4, bodyH);

        // Footprint
        if (w > 80) {
            drawFootprintInside(c, x, w, h, minPrice, maxPrice);
        }
    }

    function drawFootprintInside(candle, x, w, h, minPrice, maxPrice) {
        if (!candle.fp || typeof candle.fp !== 'object') {
            console.log('No footprint data for candle');
            return;
        }
        
        const prices = Object.keys(candle.fp).map(p => parseFloat(p)).sort((a, b) => b - a);
        
        if (prices.length === 0) {
            console.log('Empty footprint prices array');
            return;
        }
        
        ctx.font = '11px monospace';
        ctx.fontWeight = 'normal';
        
        let displayedCount = 0;
        
        prices.forEach(price => {
            const key = price.toFixed(2);
            const fp = candle.fp[key];
            if (!fp || typeof fp !== 'object') return;
            
            const y = h - ((price - minPrice) / (maxPrice - minPrice)) * h;

            // Skip if outside candle range
            if (price < candle.l || price > candle.h) return;

            const bidVol = fp.b || 0;
            const askVol = fp.a || 0;
            
            if (bidVol === 0 && askVol === 0) return;

            const total = bidVol + askVol;
            const ratio = bidVol / Math.max(askVol, 0.01);
            const isImbalance = ratio > 1.5 || ratio < (1/1.5);

            // Bid (left side)
            if (bidVol > 0) {
                const color = isImbalance && bidVol > askVol ? '#fbbf24' : CONFIG.colors.bidVol;
                const bg = isImbalance && bidVol > askVol ? 'rgba(251, 191, 36, 0.2)' : 'transparent';
                
                if (bg !== 'transparent') {
                    ctx.fillStyle = bg;
                    ctx.fillRect(x + 6, y - 7, w/2 - 8, 14);
                }
                
                ctx.fillStyle = color;
                ctx.textAlign = 'left';
                ctx.font = isImbalance && bidVol > askVol ? 'bold 11px monospace' : '11px monospace';
                ctx.fillText(Math.round(bidVol), x + 8, y + 4);
                displayedCount++;
            }

            // Ask (right side)
            if (askVol > 0) {
                const color = isImbalance && askVol > bidVol ? '#ef8b5f' : CONFIG.colors.askVol;
                const bg = isImbalance && askVol > bidVol ? 'rgba(239, 139, 95, 0.2)' : 'transparent';
                
                if (bg !== 'transparent') {
                    ctx.fillStyle = bg;
                    ctx.fillRect(x + w/2 + 2, y - 7, w/2 - 8, 14);
                }
                
                ctx.fillStyle = color;
                ctx.textAlign = 'right';
                ctx.font = isImbalance && askVol > bidVol ? 'bold 11px monospace' : '11px monospace';
                ctx.fillText(Math.round(askVol), x + w - 8, y + 4);
                displayedCount++;
            }
        });
        
        if (displayedCount > 0) {
            console.log(`Displayed ${displayedCount} footprint entries in candle`);
        }
    }

    function drawPriceScale(w, h, minPrice, maxPrice) {
        ctx.fillStyle = CONFIG.colors.bg;
        ctx.fillRect(w - 80, 0, 80, h);

        ctx.font = '11px monospace';
        ctx.fillStyle = CONFIG.colors.text;
        ctx.textAlign = 'left';

        const step = 50;
        const startPrice = Math.floor(minPrice / step) * step;

        for (let p = startPrice; p <= maxPrice; p += step) {
            const y = h - ((p - minPrice) / (maxPrice - minPrice)) * h;
            ctx.fillText(p.toFixed(0), w - 72, y + 4);
        }
    }

    function updateFootprintBar() {
        const container = document.getElementById('footprintBar');
        if (!container) {
            console.error('Footprint container not found');
            return;
        }
        
        const allCandles = [...candles];
        if (currentCandle) allCandles.push(currentCandle);

        if (allCandles.length === 0) {
            container.innerHTML = '<div style="padding: 20px; color: #888; text-align: center;">Waiting for candle data...</div>';
            return;
        }

        let html = '';
        const displayCandles = allCandles.slice(-10); // Last 10 candles
        
        displayCandles.forEach((candle, idx) => {
            let bidVol = 0, askVol = 0;
            
            if (candle.fp && typeof candle.fp === 'object') {
                Object.values(candle.fp).forEach(fp => {
                    if (fp && typeof fp === 'object') {
                        bidVol += fp.b || 0;
                        askVol += fp.a || 0;
                    }
                });
            }

            const delta = bidVol - askVol;
            const volume = candle.v || 0;
            const deltaClass = delta >= 0 ? 'positive' : 'negative';

            const time = new Date(candle.t).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

            html += `
                <div class="fp-column">
                    <div class="fp-title-row">
                        <span class="fp-title">${time}</span>
                    </div>
                    <div class="fp-stats-grid">
                        <div class="fp-stat-cell">
                            <div class="fp-stat-value">${formatVolume(volume)}</div>
                            <div class="fp-stat-label">Vol</div>
                        </div>
                        <div class="fp-stat-cell">
                            <div class="fp-stat-value ${deltaClass}">${delta >= 0 ? '+' : ''}${formatVolume(delta)}</div>
                            <div class="fp-stat-label">Î”</div>
                        </div>
                        <div class="fp-stat-cell">
                            <div class="fp-stat-value">${formatVolume(bidVol)}</div>
                            <div class="fp-stat-label">Bid Vol</div>
                        </div>
                        <div class="fp-stat-cell">
                            <div class="fp-stat-value">${formatVolume(askVol)}</div>
                            <div class="fp-stat-label">Ask Vol</div>
                        </div>
                    </div>
                </div>
            `;
        });

        container.innerHTML = html;
        console.log(`âœ… Updated footprint bar with ${displayCandles.length} candles`);
    }

    function updateCVDBar() {
        const container = document.getElementById('cvdValues');
        if (!container) {
            console.error('CVD container not found');
            return;
        }
        
        const allCandles = [...candles];
        if (currentCandle) allCandles.push(currentCandle);

        if (allCandles.length === 0) {
            container.innerHTML = '<div class="cvd-value">0</div>';
            return;
        }

        let runningCVD = 0;
        let html = '';
        
        const displayCandles = allCandles.slice(-5); // Last 5 values
        
        displayCandles.forEach((candle, idx) => {
            let bidVol = 0, askVol = 0;
            
            if (candle.fp && typeof candle.fp === 'object') {
                Object.values(candle.fp).forEach(fp => {
                    if (fp && typeof fp === 'object') {
                        bidVol += fp.b || 0;
                        askVol += fp.a || 0;
                    }
                });
            }

            const delta = bidVol - askVol;
            runningCVD += delta;
            const cvdClass = runningCVD >= 0 ? 'positive' : 'negative';

            html += `<div class="cvd-value ${cvdClass}">${runningCVD >= 0 ? '+' : ''}${formatVolume(runningCVD)}</div>`;
        });

        container.innerHTML = html;
        console.log(`âœ… Updated CVD bar with ${displayCandles.length} values, CVD: ${runningCVD.toFixed(2)}`);
    }

    function formatVolume(vol) {
        if (Math.abs(vol) >= 1000000) {
            return (vol / 1000000).toFixed(1) + 'M';
        } else if (Math.abs(vol) >= 1000) {
            return (vol / 1000).toFixed(0) + 'K';
        }
        return vol.toFixed(2);
    }

    // Controls
    let isDragging = false;
    let lastX = 0;
    let lastY = 0;
    let velocityX = 0;
    let isCoasting = false;

    // Mouse controls
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        lastX = e.clientX;
        velocityX = 0;
        isCoasting = false;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (isDragging) {
            const dx = e.clientX - lastX;
            scrollOffset += dx;
            velocityX = dx;
            lastX = e.clientX;
            draw();
        }
    });

    canvas.addEventListener('mouseup', () => {
        if (isDragging && Math.abs(velocityX) > 2) {
            startCoasting();
        }
        isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
    });

    // Touch controls for mobile
    let touchStartX = 0;
    let touchStartY = 0;
    let lastTouchX = 0;
    let lastTouchTime = 0;

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 1) {
            isDragging = true;
            touchStartX = e.touches[0].clientX;
            lastTouchX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            lastTouchTime = Date.now();
            velocityX = 0;
            isCoasting = false;
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (isDragging && e.touches.length === 1) {
            const touch = e.touches[0];
            const dx = touch.clientX - lastTouchX;
            const now = Date.now();
            const dt = now - lastTouchTime;
            
            scrollOffset += dx;
            velocityX = dx / Math.max(dt, 1) * 16; // Normalize to 60fps
            
            lastTouchX = touch.clientX;
            lastTouchTime = now;
            draw();
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (isDragging && Math.abs(velocityX) > 1) {
            startCoasting();
        }
        isDragging = false;
        e.preventDefault();
    }, { passive: false });

    canvas.addEventListener('touchcancel', () => {
        isDragging = false;
        isCoasting = false;
    });

    // Momentum scrolling
    function startCoasting() {
        isCoasting = true;
        
        function coast() {
            if (!isCoasting) return;
            
            scrollOffset += velocityX;
            velocityX *= 0.92; // Friction
            
            if (Math.abs(velocityX) < 0.1) {
                isCoasting = false;
                return;
            }
            
            draw();
            requestAnimationFrame(coast);
        }
        
        coast();
    }

    // Pinch zoom for mobile
    let lastTouchDistance = 0;

    canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (lastTouchDistance > 0) {
                const delta = distance / lastTouchDistance;
                zoomLevel = Math.max(0.5, Math.min(3, zoomLevel * delta));
                draw();
            }
            
            lastTouchDistance = distance;
            e.preventDefault();
        }
    }, { passive: false });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomLevel = Math.max(0.5, Math.min(3, zoomLevel * delta));
        draw();
    }, { passive: false });

    // Timeframe selector
    document.querySelectorAll('.tf-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            candleInterval = parseInt(btn.dataset.tf);
            candleStartTime = alignToTimeframe(Date.now(), candleInterval);
            currentCandle = null;
        });
    });

    // Tool buttons
    document.querySelectorAll('.tool-icon').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tool-icon').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        });
    });

    // Initialize
    connectToBybit();
    console.log('ðŸš€ Professional Orderflow Chart Ready');
</script>
```

</body>
</html>