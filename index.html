<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>BTC Orderflow - Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
        -webkit-font-smoothing: antialiased;
        touch-action: none;
    }

    .top-bar {
        height: 50px;
        background: #0a0a0a;
        border-bottom: 1px solid #1a1a1a;
        display: flex;
        align-items: center;
        padding: 0 12px;
        gap: 12px;
    }

    .symbol {
        font-size: 14px;
        font-weight: 700;
        color: #fff;
    }

    .timeframe-btns {
        display: flex;
        gap: 4px;
        background: #1a1a1a;
        padding: 3px;
        border-radius: 6px;
    }

    .tf-btn {
        padding: 5px 10px;
        background: transparent;
        border: none;
        color: #888;
        font-size: 11px;
        font-weight: 600;
        border-radius: 4px;
    }

    .tf-btn.active {
        background: #2563eb;
        color: #fff;
    }

    .price-display {
        margin-left: auto;
        font-size: 14px;
        font-weight: 700;
        color: #10b981;
    }

    .status {
        position: fixed;
        top: 55px;
        right: 12px;
        padding: 4px 8px;
        background: rgba(16, 185, 129, 0.2);
        border: 1px solid rgba(16, 185, 129, 0.4);
        border-radius: 4px;
        font-size: 10px;
        color: #10b981;
        z-index: 1000;
    }

    .chart-container {
        height: calc(100vh - 50px - 40px - 180px);
        position: relative;
        background: #000;
    }

    canvas {
        display: block;
        touch-action: none;
    }

    .cvd-bar {
        height: 40px;
        background: #0a0a0a;
        border-top: 1px solid #1a1a1a;
        border-bottom: 1px solid #1a1a1a;
        display: flex;
        align-items: center;
        padding: 0 12px;
        gap: 16px;
        overflow-x: auto;
    }

    .cvd-label {
        font-size: 11px;
        color: #888;
        font-weight: 600;
    }

    .cvd-value {
        font-size: 12px;
        font-weight: 700;
        white-space: nowrap;
    }

    .cvd-value.pos {
        color: #10b981;
    }

    .cvd-value.neg {
        color: #ef4444;
    }

    .fp-bar {
        height: 180px;
        background: #0a0a0a;
        border-top: 1px solid #1a1a1a;
        display: flex;
        overflow-x: auto;
        overflow-y: hidden;
    }

    .fp-bar::-webkit-scrollbar {
        display: none;
    }

    .fp-col {
        min-width: 100px;
        flex-shrink: 0;
        border-right: 1px solid #1a1a1a;
        display: flex;
        flex-direction: column;
    }

    .fp-time {
        height: 35px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-bottom: 1px solid #1a1a1a;
        font-size: 10px;
        color: #888;
        font-weight: 600;
    }

    .fp-grid {
        flex: 1;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1px;
        background: #1a1a1a;
        padding: 1px;
    }

    .fp-cell {
        background: #0a0a0a;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 6px;
    }

    .fp-val {
        font-size: 13px;
        font-weight: 700;
    }

    .fp-val.pos {
        color: #10b981;
    }

    .fp-val.neg {
        color: #ef4444;
    }

    .fp-lbl {
        font-size: 8px;
        color: #888;
        margin-top: 2px;
    }

    .loading {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        color: #888;
    }
</style>
```

</head>
<body>
    <div class="top-bar">
        <div class="symbol">BTCUSDT</div>
        <div class="timeframe-btns">
            <button class="tf-btn" data-tf="60000">1m</button>
            <button class="tf-btn" data-tf="300000">5m</button>
            <button class="tf-btn active" data-tf="900000">15m</button>
            <button class="tf-btn" data-tf="3600000">1h</button>
        </div>
        <div class="price-display" id="price">--</div>
    </div>

```
<div class="status">ðŸŸ¢ Live</div>

<div class="chart-container">
    <canvas id="canvas"></canvas>
</div>

<div class="cvd-bar">
    <span class="cvd-label">CVD</span>
    <div id="cvdVals"></div>
</div>

<div class="fp-bar" id="fpBar"></div>

<div class="loading" id="loading">Connecting...</div>

<script>
    // Config
    const CFG = {
        cw: 40,  // Candle width
        gap: 4,   // Gap
        colors: {
            bg: '#000',
            grid: '#1a1a1a',
            bull: '#b8860b',
            bear: '#cd853f',
            bullBorder: '#daa520',
            bearBorder: '#d2691e',
            current: '#fbbf24',
            text: '#888'
        }
    };

    // State
    let candles = [];
    let current = null;
    let interval = 15 * 60 * 1000;
    let startTime = align(Date.now(), interval);
    let zoom = 1;
    let scroll = 0;
    let socket = null;
    let connected = false;

    // Canvas
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = rect.width + 'px';
        canvas.style.height = rect.height + 'px';
        ctx.scale(dpr, dpr);
        draw();
    }

    window.addEventListener('resize', resize);
    resize();

    function align(ts, int) {
        const d = new Date(ts);
        const m = d.getMinutes();
        const im = int / 60000;
        const am = Math.floor(m / im) * im;
        d.setMinutes(am, 0, 0);
        return d.getTime();
    }

    // Connect
    function connect() {
        console.log('Connecting...');
        socket = new WebSocket('wss://stream.bybit.com/v5/public/linear');
        
        socket.onopen = () => {
            console.log('Connected');
            connected = true;
            document.getElementById('loading').style.display = 'none';
            socket.send(JSON.stringify({
                op: 'subscribe',
                args: ['publicTrade.BTCUSDT']
            }));
        };
        
        socket.onmessage = (e) => {
            const data = JSON.parse(e.data);
            if (data.topic && data.topic.includes('publicTrade')) {
                process(data);
            }
        };
        
        socket.onerror = () => {
            connected = false;
        };
        
        socket.onclose = () => {
            connected = false;
            setTimeout(connect, 3000);
        };
    }

    function process(msg) {
        if (!msg.data || msg.data.length === 0) return;
        
        msg.data.forEach(t => {
            const p = parseFloat(t.p);
            const q = parseFloat(t.v);
            const sell = t.S === 'Sell';
            
            if (!current) {
                current = {
                    t: align(Date.now(), interval),
                    o: p, h: p, l: p, c: p, v: 0, fp: {}
                };
            }
            
            current.h = Math.max(current.h, p);
            current.l = Math.min(current.l, p);
            current.c = p;
            current.v += q;
            
            const k = p.toFixed(2);
            if (!current.fp[k]) current.fp[k] = { b: 0, a: 0 };
            
            if (sell) {
                current.fp[k].b += q;
            } else {
                current.fp[k].a += q;
            }
            
            document.getElementById('price').textContent = '$' + p.toFixed(2);
            draw();
            updateFP();
            updateCVD();
        });
    }

    function checkInterval() {
        const now = Date.now();
        const curr = align(now, interval);
        
        if (curr > startTime && current) {
            candles.push(current);
            if (candles.length > 100) candles.shift();
            current = null;
            startTime = curr;
        }
    }
    setInterval(checkInterval, 1000);

    // Draw
    function draw() {
        const w = canvas.width / (window.devicePixelRatio || 1);
        const h = canvas.height / (window.devicePixelRatio || 1);

        ctx.fillStyle = CFG.colors.bg;
        ctx.fillRect(0, 0, w, h);

        const all = [...candles];
        if (current) all.push(current);

        if (all.length === 0) return;

        let minP = Infinity, maxP = -Infinity;
        all.forEach(c => {
            minP = Math.min(minP, c.l);
            maxP = Math.max(maxP, c.h);
        });

        const pad = (maxP - minP) * 0.1;
        minP -= pad;
        maxP += pad;

        // Grid
        ctx.strokeStyle = CFG.colors.grid;
        ctx.lineWidth = 1;
        const step = 50;
        const sp = Math.floor(minP / step) * step;
        for (let p = sp; p <= maxP; p += step) {
            const y = h - ((p - minP) / (maxP - minP)) * h;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(w - 50, y);
            ctx.stroke();
        }

        // Candles
        const cw = CFG.cw * zoom;
        const gap = CFG.gap * zoom;
        const tw = all.length * (cw + gap);
        const sx = w - tw - 50 + scroll;

        all.forEach((c, i) => {
            const x = sx + i * (cw + gap);
            if (x + cw < 0 || x > w - 50) return;
            drawCandle(c, x, cw, h, minP, maxP, i === all.length - 1);
        });

        // Price scale
        ctx.fillStyle = CFG.colors.bg;
        ctx.fillRect(w - 50, 0, 50, h);
        ctx.font = '9px monospace';
        ctx.fillStyle = CFG.colors.text;
        ctx.textAlign = 'left';
        for (let p = sp; p <= maxP; p += step) {
            const y = h - ((p - minP) / (maxP - minP)) * h;
            ctx.fillText(p.toFixed(0), w - 46, y + 3);
        }
    }

    function drawCandle(c, x, w, h, minP, maxP, curr) {
        const py = p => h - ((p - minP) / (maxP - minP)) * h;
        const oy = py(c.o), cy = py(c.c), hy = py(c.h), ly = py(c.l);
        const green = c.c >= c.o;
        const col = curr ? CFG.colors.current : (green ? CFG.colors.bullBorder : CFG.colors.bearBorder);

        // Wick
        ctx.strokeStyle = col;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + w/2, hy);
        ctx.lineTo(x + w/2, ly);
        ctx.stroke();

        // Body
        const top = Math.min(oy, cy);
        const bh = Math.abs(cy - oy) || 2;
        ctx.fillStyle = green ? CFG.colors.bull : CFG.colors.bear;
        ctx.fillRect(x, top, w, bh);
        ctx.strokeStyle = col;
        ctx.lineWidth = curr ? 3 : 2;
        ctx.strokeRect(x, top, w, bh);

        // Footprint
        if (w > 25 && c.fp) {
            const ps = Object.keys(c.fp).map(p => parseFloat(p)).sort((a, b) => b - a);
            ctx.font = '8px monospace';
            
            ps.forEach(price => {
                const k = price.toFixed(2);
                const fp = c.fp[k];
                if (!fp) return;
                
                const y = py(price);
                if (price < c.l || price > c.h) return;

                const b = fp.b || 0;
                const a = fp.a || 0;
                if (b === 0 && a === 0) return;

                const ratio = b / Math.max(a, 0.01);
                const imb = ratio > 1.5 || ratio < 0.67;

                if (b > 0) {
                    ctx.fillStyle = imb && b > a ? '#fbbf24' : CFG.colors.bull;
                    ctx.textAlign = 'left';
                    ctx.fillText(Math.round(b), x + 2, y + 3);
                }

                if (a > 0) {
                    ctx.fillStyle = imb && a > b ? '#ef8b5f' : CFG.colors.bear;
                    ctx.textAlign = 'right';
                    ctx.fillText(Math.round(a), x + w - 2, y + 3);
                }
            });
        }
    }

    function updateFP() {
        const bar = document.getElementById('fpBar');
        const all = [...candles];
        if (current) all.push(current);

        let html = '';
        all.slice(-10).forEach(c => {
            let b = 0, a = 0;
            if (c.fp) {
                Object.values(c.fp).forEach(f => {
                    b += f.b || 0;
                    a += f.a || 0;
                });
            }

            const d = b - a;
            const v = c.v || 0;
            const t = new Date(c.t).toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'});

            html += `
                <div class="fp-col">
                    <div class="fp-time">${t}</div>
                    <div class="fp-grid">
                        <div class="fp-cell">
                            <div class="fp-val">${fmt(v)}</div>
                            <div class="fp-lbl">Vol</div>
                        </div>
                        <div class="fp-cell">
                            <div class="fp-val ${d >= 0 ? 'pos' : 'neg'}">${d >= 0 ? '+' : ''}${fmt(d)}</div>
                            <div class="fp-lbl">Î”</div>
                        </div>
                        <div class="fp-cell">
                            <div class="fp-val">${fmt(b)}</div>
                            <div class="fp-lbl">Bid</div>
                        </div>
                        <div class="fp-cell">
                            <div class="fp-val">${fmt(a)}</div>
                            <div class="fp-lbl">Ask</div>
                        </div>
                    </div>
                </div>
            `;
        });

        bar.innerHTML = html;
    }

    function updateCVD() {
        const el = document.getElementById('cvdVals');
        const all = [...candles];
        if (current) all.push(current);

        let cvd = 0;
        let html = '';
        all.slice(-5).forEach(c => {
            let b = 0, a = 0;
            if (c.fp) {
                Object.values(c.fp).forEach(f => {
                    b += f.b || 0;
                    a += f.a || 0;
                });
            }
            cvd += b - a;
            html += `<span class="cvd-value ${cvd >= 0 ? 'pos' : 'neg'}">${cvd >= 0 ? '+' : ''}${fmt(cvd)}</span>`;
        });

        el.innerHTML = html;
    }

    function fmt(n) {
        if (Math.abs(n) >= 1000000) return (n / 1000000).toFixed(1) + 'M';
        if (Math.abs(n) >= 1000) return (n / 1000).toFixed(0) + 'K';
        return n.toFixed(2);
    }

    // Touch
    let drag = false;
    let lastX = 0;
    let vel = 0;
    let coast = false;

    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 1) {
            drag = true;
            lastX = e.touches[0].clientX;
            vel = 0;
            coast = false;
            e.preventDefault();
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        if (drag && e.touches.length === 1) {
            const dx = e.touches[0].clientX - lastX;
            scroll += dx;
            vel = dx;
            lastX = e.touches[0].clientX;
            draw();
            e.preventDefault();
        }
    }, {passive: false});

    canvas.addEventListener('touchend', e => {
        if (drag && Math.abs(vel) > 1) {
            coast = true;
            requestAnimationFrame(function c() {
                if (!coast) return;
                scroll += vel;
                vel *= 0.92;
                if (Math.abs(vel) < 0.1) {
                    coast = false;
                    return;
                }
                draw();
                requestAnimationFrame(c);
            });
        }
        drag = false;
        e.preventDefault();
    }, {passive: false});

    // Pinch zoom
    let lastDist = 0;
    canvas.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            lastDist = Math.sqrt(dx * dx + dy * dy);
            e.preventDefault();
        }
    }, {passive: false});

    canvas.addEventListener('touchmove', e => {
        if (e.touches.length === 2) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (lastDist > 0) {
                const delta = dist / lastDist;
                zoom = Math.max(0.5, Math.min(3, zoom * delta));
                draw();
            }
            
            lastDist = dist;
            e.preventDefault();
        }
    }, {passive: false});

    // Timeframe
    document.querySelectorAll('.tf-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            document.querySelectorAll('.tf-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            interval = parseInt(btn.dataset.tf);
            startTime = align(Date.now(), interval);
            current = null;
        });
    });

    // Init
    connect();
    console.log('Ready');
</script>
```

</body>
</html>